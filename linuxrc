#!/static/sh
#
# sidux general startup script
# (C) Klaus Knopper <knoppix@knopper.net>
# (C) 2003-2006 Joerg Schirottke <master@kanotix.com>
# (C) 2006 Stefan Lippers-Hollmann <s.l-h@gmx.de>
#
# This script needs some of the builtin busybox commands (if, test, ...)
# mount/umount, insmod/rmmod are also a builtin in busybox.
#

# override tool behaviour through distro-defaults
FLL_DISTRO_NAME="sidux"
FLL_DISTRO_MODE="live"
FLL_LIVE_USER="sidux"
FLL_IMAGE_DIR="SIDUX"
FLL_IMAGE_FILE="SIDUX"
FLL_IMAGE="$FLL_IMAGE_DIR/$FLL_IMAGE_FILE"
FLL_MOUNTPOINT="/SIDUX"
FLL_UNION_SOURCE="/ramdisk/var/tmp/union"
FLL_UNION_TARGET="$FLL_MOUNTPOINT"
FLL_UNION_OPTIONS="rw"
FLL_PERSISTENT_HOME="sidux.img"
FLL_ISO_DIR="SIDUX"
FLL_ISO_NAME="SIDUX.ISO"
FLL_ISO="$FLL_ISO_DIR/$FLL_ISO_NAME"
FLL_MEDIUM="cdrom"

# hardcoded configurable options
# Default maximum size of dynamic ramdisk in kilobytes
RAMSIZE=1000000
# End of options

# look for kernel modules in these directories
MODULE_DIRS="/$FLL_MEDIUM/$FLL_IMAGE_DIR/modules /modules /modules/scsi"

# Builtin fielsystems
BUILTIN_FS="iso9660 ext2 ext3 reiserfs vfat reiser"

# Don't allow interrupt signals
trap "" 1 2 3 15

# Misc functions
mountit()
{
	# Usage: mountit src dst "options"
	# Uses builtin mount of busybox
	for fs in $BUILTIN_FS; do
		case "$fs" in
			ntfs)
				MOUNTIT_OPT=" -o uid=1000,gid=1000 "
				;;
			*)
				MOUNTIT_OPT=""
				;;
		esac
		
		test -b $1 && mount -t $fs $3 $MOUNTIT_OPT $1 $2 >/dev/null 2>&1 && return 0
	done

	return 1
}

FOUND_SCSI=""
FOUND_KNOPPIX=""
INTERACTIVE=""

# Clean input/output
exec >/dev/console </dev/console 2>&1

# Reset fb color mode
RESET="]R"
# ANSI COLORS
# Erase to end of line
CRE="
[K"
# Clear and reset Screen
CLEAR="c"
# Normal color
NORMAL="[0;39m"
# RED: Failure or error message
RED="[1;31m"
# GREEN: Success message
GREEN="[1;32m"
# YELLOW: Descriptions
YELLOW="[1;33m"
# BLUE: System mesages
BLUE="[1;34m"
# MAGENTA: Found devices or drivers
MAGENTA="[1;35m"
# CYAN: Questions
CYAN="[1;36m"
# BOLD WHITE: Hint
WHITE="[1;37m"

# We only need the builtin commands and /static at this point
PATH=/static
export PATH

umask 022

# Mount /proc, /sys and /dev/pts
mount -t proc /proc /proc
mount -t sysfs /sys /sys
mount -t devpts -o noexec,nosuid devpts /dev/pts

# Disable kernel messages while probing modules in autodetect mode
echo "0" > /proc/sys/kernel/printk

# Dynamic program loader
# $FLL_MOUNTPOINT is already mounted when this is used.
# fallback to i386 defaults.
ARCHITECTURE="$(uname -m)"
DYNLOADER="$FLL_MOUNTPOINT/lib/ld-linux.so.2"
[ "$ARCHITECTURE" = "x86_64" ] && DYNLOADER="$FLL_MOUNTPOINT/lib/ld-linux-x86-64.so.2"
#[ "$ARCHITECTURE" = "sparc" ] &&  DYNLOADER="$FLL_MOUNTPOINT/lib/ld-linux.so.2"	# default anyways

# Clear screen with colormode reset
# echo "$CLEAR$RESET"
# echo "$CLEAR"
# Just go to the top of the screen
# echo -n "[H[J"
echo ""
# Be verbose
echo "${WHITE}Welcome to $FLL_DISTRO_NAME ($ARCHITECTURE) live linux!${NORMAL}"
echo ""
echo ""

# Read boot command line with builtin cat command (shell read function fails in Kernel 2.4.19-rc1)
CMDLINE="$(cat /proc/cmdline)"

# Check if we are in interactive startup mode
case "$CMDLINE" in
	*BOOT_IMAGE=expert\ *)
		INTERACTIVE="yes"
		:>/interactive
		;;
esac

case "$CMDLINE" in
	*modules-disk*)
		INTERACTIVE="yes"
		;;
esac

# enable debugging?
case "$CMDLINE" in
	*BOOT_IMAGE=debug\ *|*\ debug\ *)
		DEBUG="yes"
		;;
esac

# Does the user want to skip scsi detection?
NOSCSI=""
case "$CMDLINE" in
	*noscsi*|*nobootscsi*)
	NOSCSI="yes"
	;;
esac
case "$CMDLINE" in
	*scsiisa*)
	SCSI_PROBE="$ISA_SCSI $SCSI_PROBE"
	;;
esac

NOUSB="yes"
case "$CMDLINE" in
	*bootusb*)
		NOUSB=""
		;;
esac

NOFIREWIRE="yes"
case "$CMDLINE" in
	*bootfirewire*)
		NOFIREWIRE=""
		;;
esac

NOCD=""
case "$CMDLINE" in
	*fromhd*)
		NOCD="yes"
		;;
esac
case "$CMDLINE" in
	*fromdvd*)
		FROMDVD="yes"
		;;
esac
case "$CMDLINE" in
	*fromiso*)
		FROMISO="yes"
		mkdir /isosrc
		;;
esac
case "$CMDLINE" in
	*idecd*|*atapicd*)
		IDECD="yes"
		;;
esac

NOIDERAID="yes"
case "$CMDLINE" in
	*ideraid*)
		NOIDERAID=""
		;;
esac
case "$CMDLINE" in
	*bootusb2*)
	USB2="ehci-hcd.o"
	;;
esac

case "$CMDLINE" in
	*knoppix_dir=*)
		FLL_IMAGE_DIR="$knoppix_dir"
		;;
esac
case "$CMDLINE" in
	*knoppix_name=*)
		FLL_IMAGE_FILE="$knoppix_name"
		;;
esac

case "$CMDLINE" in
	*knoppix_iso_dir=*)
		FLL_ISO_DIR="$knoppix_iso_dir"
		;;
esac
case "$CMDLINE" in
	*knoppix_iso_name=*)
		FLL_ISO_NAME="$knoppix_iso_name"
		;;
esac

case "$CMDLINE" in
	*fromiso=*)
		FLL_ISO="$fromiso"
		;;
esac

FLL_IMAGE="$FLL_IMAGE_DIR/$FLL_IMAGE_FILE"
FLL_ISO="$FLL_ISO_DIR/$FLL_ISO_NAME"

# Run a shell if in debug mode
stage=1
rundebugshell()
{
	if [ -n "$DEBUG" ]; then
		echo "${CRE}${BLUE}Starting intermediate Shell stage $stage as requested by \"debug\" option.${NORMAL}"
		echo "${CRE}${BLUE}Type \"exit\" to continue with normal bootup.${NORMAL}"
		[ -x /static/ash ] && /static/ash || /bin/bash
	fi
}

# Mount module disk
mountmodules()
{
	TYPE="$1"
	shift

	echo -n "${CRE}${CYAN}Please insert ${TYPE} modules disk and hit Return. ${NORMAL}"
	read a
	echo -n "${CRE}${BLUE}Mounting ${TYPE} modules disk... ${NORMAL}"
	
	# We always mount over /modules/scsi (because it's there ;-)
	if mountit /dev/fd0 /modules/scsi "-o ro"; then
		echo "${GREEN}OK.${NORMAL}"
		return 0
	fi
	
	echo "${RED}NOT FOUND.${NORMAL}"
	
	return 1
}

# Unmount module disk
umountmodules()
{
	TYPE="$1"
	shift

	echo -n "${CRE}${BLUE}Unmounting ${TYPE} modules disk... ${NORMAL}"
	umount /modules/scsi 2>/dev/null
	echo "${GREEN}DONE.${NORMAL}"
}

# Ask user for modules
askmodules()
{
	TYPE="$1"
	shift

	echo "${BLUE}${TYPE} modules available:${WHITE}"
	c=""
	for m in "$@"; do
		if test -r "/modules/scsi/$m"; then
			test -z "$c"  && { echo -n "	$m"; c="1"; } || { echo "		$m"; c=""; }
		fi
	done

	[ -n "$c" ] && echo ""
	echo "${CYAN}Load ${TYPE} Modules?${NORMAL}"
	echo "${CYAN}[Enter full filename(s) (space-separated), Return for autoprobe, ${WHITE}n${CYAN} for none] ${NORMAL}"
	echo -n "${CYAN}insmod module(s)> ${NORMAL}"
	read MODULES

	case "$MODULES" in
		n|N)
			MODULES=""
			;;
		y|"")
			MODULES="$*"
			;;
	esac
}

# Try to load the given module with optional parameters
# module can be a full path or a module.ko name
# (in which case $MODULE_DIRS is searched).
# loadmodule module options...
loadmodule()
{
	MODULE="$1"
	shift

	INSMOD=""

	# Find insmod in CURRENT file system configuration
	for p in $MODULE_DIRS /static; do
		checkfor="$p/insmod"
		if test -x "$checkfor"; then
			INSMOD="$checkfor"
			break
		fi
	done

	# At last resort, try builtin insmod
	test -z "$INSMOD" && INSMOD="insmod" # builtin insmod
	LOAD=""
	for p in $MODULE_DIRS; do
		for ext in ".ko" "" ".o"; do
			checkfor="$p/$MODULE$ext"
			if test -r "$checkfor"; then
				LOAD="$checkfor"
				break 2
			fi
		done
	done
	test -n "$LOAD" || return 1

	# For a new process to avoid crashing our main shell
	echo "$INSMOD $LOAD" "$@" | /static/ash
	return "$?"
}

# Load many modules at once
# loadmodules TYPE(comment) module ...
loadmodules()
{
	TYPE="$1"
	shift

	test -n "$INTERACTIVE" && echo "6" > /proc/sys/kernel/printk
	for m in "$@"; do
		echo -n "${CRE}${BLUE}Probing ${TYPE}... ${MAGENTA}$m${NORMAL}"
		if loadmodule "$m" >/dev/null 2>&1; then
			case "$TYPE" in
				scsi|SCSI)
					FOUND_SCSI="yes"
					;;
			esac
		fi
	done

	test -n "$INTERACTIVE" && echo "0" > /proc/sys/kernel/printk
	echo -n "${CRE}"
}

unloadmodule()
{
	MODULE="$1"
	RMMOD=""

	# Find insmod in CURRENT file system configuration
	for p in $MODULE_DIRS /static; do
		checkfor="$p/rmmod"
		if test -x "$checkfor"; then
			RMMOD="$checkfor"; break
		fi
	done

	# At last resort, try builtin insmod
	test -z "$RMMOD" && RMMOD="rmmod" # builtin rmmod

	# For a new process to avoid crashing our main shell
	echo "$RMMOD" "$MODULE" | /static/ash
	return "$?"
}

# Check for SCSI, use modules on bootfloppy first
ISA_SCSI="aha1740 aha1542 aha152x pas16 psi240i qlogicfas qlogicfc seagate t128 u14-34f wd7000"

# Trying to do kind of /proc/pci hardware detection
# SCSI detection using /sys/devices
for d in /sys/devices/*/*; do
	if test -r "$d"/class -a -r "$d"/vendor -a -r "$d"/device; then
		read CLASS  < "$d"/class 2>/dev/null
		
		case "$CLASS" in
			0x0100*)
				read VENDOR < "$d"/vendor 2>/dev/null
				read DEVICE < "$d"/device 2>/dev/null
				
				case "$VENDOR:$DEVICE" in
					*1000:*00[0-2]?)
						SCSI_PROBE="$SCSI_PROBE sym53c8xx"
						;;
					*1000:*040?|*1000:*196?|*101e:*196?|*1028:*000[ef]|*1028:*0013)
						SCSI_PROBE="$SCSI_PROBE megaraid_mbox"
						;;
					*1000:*04[1-9]?|*1028:*0015)
						SCSI_PROBE="$SCSI_PROBE megaraid_sas"
						;;
					*1001:*9100|*1101:*)
						SCSI_PROBE="$SCSI_PROBE initio"
						;;
					*9004:*|*9005:*00??)
						SCSI_PROBE="$SCSI_PROBE aic7xxx"
						;;
					*1011:*|*1028:*000[1-9a]|*9005:*02[08]?)
						SCSI_PROBE="$SCSI_PROBE aacraid"
						;;
					*1014:*002e|*1014:*01bd|*9005:*0250)
						SCSI_PROBE="$SCSI_PROBE ips"
						;;
					*1014:*0[1-2]8?|*1069:*|*9005:*0503)
						SCSI_PROBE="$SCSI_PROBE ipr"
						;;
					*1022:*)
						SCSI_PROBE="$SCSI_PROBE tmscsim"
						;;
					*1044:*)
						SCSI_PROBE="$SCSI_PROBE dpt_i2o"
						;;
					*1077:*1???)
						SCSI_PROBE="$SCSI_PROBE qla1280"
						;;
					*1077:*21??)
						SCSI_PROBE="$SCSI_PROBE qla2xxx qla2100"
						;;
					*1077:*22??)
						SCSI_PROBE="$SCSI_PROBE qla2xxx qla2200"
						;;
					*1077:*23[0-1]?)
						SCSI_PROBE="$SCSI_PROBE qla2xxx qla2300"
						;;
					*1077:*232?)
						SCSI_PROBE="$SCSI_PROBE qla2xxx qla2322"
						;;
					*1077:*24??)
						SCSI_PROBE="$SCSI_PROBE qla2xxx"
						;;
					*1077:*63??)
						SCSI_PROBE="$SCSI_PROBE qla2xxx qla6312"
						;;
					*10df:*)
						SCSI_PROBE="$SCSI_PROBE lpfc"
						;;
					*10fc:*|*1145:*)
						SCSI_PROBE="$SCSI_PROBE nsp32"
						;;
					*1101:*)
						SCSI_PROBE="$SCSI_PROBE a100u2w"
						;;
					*1119:*|*8086:*)
						SCSI_PROBE="$SCSI_PROBE gdth"
						;;
					*1191:*)
						SCSI_PROBE="$SCSI_PROBE atp870u"
						;;
					*134a:*)
						SCSI_PROBE="$SCSI_PROBE dmx3191d"
						;;
					*1de1:*)
						SCSI_PROBE="$SCSI_PROBE dc395x"
						;;
					*9005:*8???)
						SCSI_PROBE="$SCSI_PROBE aic79xx"
						;;
					*104b:*)
						SCSI_PROBE="$SCSI_PROBE BusLogic"
						;;
					*1[0d]e1:*)
						SCSI_PROBE="$SCSI_PROBE dc395x"
						;;
					*1000:*00[34]?)
						SCSI_PROBE="$SCSI_PROBE mptscsih"
						;;
					*10cd:*)
						SCSI_PROBE="$SCSI_PROBE advansys"
						;;
					*1191:*)
						SCSI_PROBE="$SCSI_PROBE atp870u"
						;;
					*134a:*)
						SCSI_PROBE="$SCSI_PROBE dtc"
						;;
					*1d44:*)
						SCSI_PROBE="$SCSI_PROBE eata"
						;;
					*1036:*)
						SCSI_PROBE="$SCSI_PROBE fdomain"
						;;
					*1256:*4201)
						SCSI_PROBE="$SCSI_PROBE pci2220i"
						;;
					*1256:*5201)
						SCSI_PROBE="$SCSI_PROBE pci2000"
						;;
					*1022:*)
						SCSI_PROBE="$SCSI_PROBE tmscsim"
						;;
					*6356:*)
						SCSI_PROBE="$SCSI_PROBE ultrastor"
						;;
					*13c1:*)
						SCSI_PROBE="$SCSI_PROBE 3w-xxxx"
						;;
				esac
				;;
		esac
	fi
done

if test -n "$INTERACTIVE"; then
	# Let the user select interactively
	askmodules SCSI $(cd /modules/scsi; echo *.ko)
else
	# these are the autoprobe-safe modules
	MODULES="$SCSI_PROBE"
fi

test -z "$NOSCSI" && test -n "$MODULES" && loadmodules SCSI $MODULES
# End of SCSI check

# Check for IDE-Raid devices
if test -z "$NOIDERAID"; then
	(
		cd /modules/scsi
		{
			loadmodule ataraid >/dev/null 2>&1 && \
			loadmodule silraid >/dev/null 2>&1
		} || \
		loadmodule medley >/dev/null 2>&1 || \
		loadmodule pdcraid >/dev/null 2>&1
	)
fi
# End of IDE-Raid check

# Check for USB, use modules on bootfloppy first
if test -z "$NOUSB"; then
	echo -n "${CRE}${BLUE}Checking for for USB...${NORMAL}"
	if loadmodule usbcore >/dev/null 2>&1; then
		FOUNDUSB=""

		for i in $USB2 uhci-hcd ohci-hcd; do
			loadmodule $i >/dev/null 2>&1 && FOUNDUSB="yes"
		done

		if test -n "$FOUNDUSB"; then
			if ! loadmodule libusual >/dev/null 2>&1 && usb-storage >/dev/null 2>&1; then
				loadmodule ub >/dev/null 2>&1
			fi
		else
			# For an unknown reason, unloading usbcore hangs sometimes
			# rmmod usbcore >/dev/null 2>&1
			true
		fi
	fi
	
	echo -n "${CRE}"
fi
# End of USB check

# Check for Firewire, use modules on bootfloppy first
if test -z "$NOFIREWIRE"; then
	echo -n "${CRE}${BLUE}Checking for Firewire...${NORMAL}"
	if loadmodule ieee1394 >/dev/null 2>&1; then
		FOUNDFIREWIRE=""
		
		for i in ohci1394; do
			echo -n "${CRE}${BLUE}Loading $i...${NORMAL}"
			loadmodule "$i" >/dev/null 2>&1 && FOUNDFIREWIRE="yes"
		done

		if test -n "$FOUNDFIREWIRE"; then
			echo -n "${CRE}${BLUE}Loading sbp2...${NORMAL}"
			loadmodule sbp2 serialize_io=1 >/dev/null 2>&1
		else
			# For an unknown reason, unloading ieee1394 hangs sometimes
			# echo -n "${CRE}${BLUE}Unloading ieee1394...${NORMAL}"
			# rmmod ieee1394 >/dev/null 2>&1
			true
		fi
	fi

	echo -n "${CRE}"
fi
# End of FIREWIRE check

# Unfortunately, hotpluggable devices tend to need some time in order to register
if test -n "$FOUNDUSB" -o -n "$FOUNDFIREWIRE"; then
	echo -n "${CRE}${BLUE}Scanning for USB/Firewire devices... ${NORMAL}"
	if test -n "$FOUNDFIREWIRE"; then
		# Wait for driver to register
		sleep 2
		
		# Kernel 2.6 does this automatically
		case "$(cat /proc/version 2>/dev/null)" in
			*version\ 2.6.*)
				;;
			*)
				for host in 0 1 2 3 4 5 6 7; do 
					for channel in 0 1; do 
						for id in 0 1 2 3 4 5 6 7; do 
							echo "scsi add-single-device $host $channel $id 0" >/proc/scsi/scsi 2>/dev/null
						done
					done
				done
				;;
		esac
	fi

	sleep 6
	echo "${BLUE}Done.${NORMAL}"
fi

# Check for misc modules in expert mode
if test -n "$INTERACTIVE"; then
	another=""
	answer=""
	while test "$answer" != "n" -a "$answer" != "N"; do
		echo -n "${CYAN}Do you want to load additional modules from$another floppy disk? [${WHITE}Y${CYAN}/n] ${NORMAL}"
		another=" another"
		read answer

		case "$answer" in
			n*|N*)
				break
				;;
		esac

		if mountmodules new; then
			askmodules new $(cd /modules/scsi; echo *.ko)
			test -n "$MODULES" && loadmodules new $MODULES
			umountmodules current
		fi
	done
fi
# All interactively requested modules should be loaded now.

# Give USB-Storage devices some more time to register
if test -d /proc/scsi/usb-storage; then
	echo -n "${CRE}${BLUE}Allowing slow USB-devices some more time to register...${NORMAL}"
	ash -c "sleep 6"
	echo "${BLUE}Ok.${NORMAL}"
fi

# Check for ide-scsi supported CD-Roms et al.
test -r /proc/scsi/scsi && FOUND_SCSI="yes"

# Disable kernel messages again
echo "0" > /proc/sys/kernel/printk

# disable DMA in case of hardware bugs
# in FROMHD or TORAM mode
case "$CMDLINE" in
	*\ nodma*)
		for d in $(cd /proc/ide 2>/dev/null && echo hd[a-z]); do
			if test -d /proc/ide/$d; then
				MODEL="$(cat /proc/ide/$d/model 2>/dev/null)"
				test -z "$MODEL" && MODEL="[GENERIC IDE DEVICE]"
				echo "${BLUE}Disabling DMA acceleration for: ${MAGENTA}$d 	${YELLOW}[${MODEL}]${NORMAL}"
				echo "using_dma:0" >/proc/ide/$d/settings
			fi
		done
		;;
esac

stage=1
rundebugshell

# Now that the right SCSI driver is (hopefully) loaded, try to find CDROM
DEVICES="/dev/hd?"
test -n "$FOUNDUSB$FOUNDFIREWIRE" && test -z "$NOCD" && DEVICES="/dev/sr? $DEVICES"

# New: Also try parallel port CD-Roms [for Mike].
DEVICES="$DEVICES /dev/pcd?"

# New: also check HD partitions for a KNOPPIX/KNOPPIX image
test -n "$FOUND_SCSI" -a -z "$NOSCSI" && DEVICES="$DEVICES /dev/sd?[1-9] /dev/sd?[1-9][0-9]"

# Look for CDROMs first
CDROM=$(awk '/name/{for (i=NF;i>=3;i--) {print "/dev/" $i}}' /proc/sys/dev/cdrom/info)
DEVICES="$CDROM $DEVICES /dev/ub?[1-9] /dev/ub?[1-9][0-9] /dev/ub? /dev/hd?[1-9] /dev/hd?[1-9][0-9]"
case "$CMDLINE" in
	*fromhd=/dev/*)
		DEVICES="$fromhd"
		;;
esac

for i in $DEVICES; do
	echo -n "${CRE}${BLUE}Looking for ${FLL_MEDIUM} in: ${MAGENTA}$i${NORMAL}   "
	if test -z "$FROMISO"; then
		if mountit $i /$FLL_MEDIUM "-o ro" >/dev/null 2>&1; then
			if test -r /$FLL_MEDIUM/$FLL_IMAGE; then
				echo -n "${CRE}${GREEN}Accessing $FLL_DISTRO_NAME ${FLL_MEDIUM} at ${MAGENTA}$i${GREEN}...${NORMAL}"
				FOUND_KNOPPIX="$i"
				break
			fi
			
			umount /$FLL_MEDIUM
		fi
	else
		if mountit $i /isosrc "-o ro" >/dev/null 2>&1; then
			if test -f /isosrc/$FLL_ISO; then
				if mount -o loop,ro /isosrc/$FLL_ISO /$FLL_MEDIUM >/dev/null 2>&1; then
					if test -f /$FLL_MEDIUM/$FLL_IMAGE; then
						echo -n "${CRE} ${GREEN}Accessing $FLL_DISTRO_NAME image at ${MAGENTA}$i/$FLL_IMAGE${GREEN}...${NORMAL}"
						FOUND_KNOPPIX="$i/$FLL_ISO"
						break
					fi
			
				umount /$FLL_MEDIUM
				fi
			fi
		
			umount /isosrc
		fi
	fi
done

# Harddisk-installed script part version has been removed
# (KNOPPIX can be booted directly from HD now).
mount_knoppix()
{
	if test -n "$FOUND_KNOPPIX" && test -f $1/$FLL_IMAGE; then
		# DEBUG
		# echo "6" > /proc/sys/kernel/printk
		# detect compression
		COMP=""
		case $(dd if=$1/$FLL_IMAGE bs=4 count=1 2>/dev/null) in
			"#!/b")
				COMP=cloop
				loadmodule cloop file="$1/$FLL_IMAGE"
				mountit /dev/cloop /$FLL_MOUNTPOINT "-o ro" || FOUND_KNOPPIX=""
				;;
			"hsqs")
				COMP=squashfs
				loadmodule loop
				loadmodule squashfs 
				mount -t squashfs $1/$FLL_IMAGE /$FLL_MOUNTPOINT -o loop,ro || FOUND_KNOPPIX=""
				;;
		esac
	fi

	#FIXME
	## Allow multi-image KNOPPIX mounts
	#if [ -n "$FOUND_KNOPPIX" ] && [ -x "$DYNLOADER" ] && [ -x /KNOPPIX/sbin/losetup ]; then
	#	echo ""
	#	echo -n "${CRE} ${GREEN}Found primary KNOPPIX compressed image at ${MAGENTA}$1/$KNOPPIX_DIR/$KNOPPIX_NAME${GREEN}.${NORMAL}"
	#	
	#	for c in 1 2 3 4 5 6 7; do
	#		if test -r "$1/$KNOPPIX_DIR/$KNOPPIX_NAME$c"; then
	#			if "$DYNLOADER" --library-path /KNOPPIX/lib /KNOPPIX/sbin/losetup "/dev/cloop$c" "$1/$KNOPPIX_DIR/$KNOPPIX_NAME$c"; then
	#				if "$DYNLOADER" --library-path /KNOPPIX/lib /KNOPPIX/bin/mkdir -p "/KNOPPIX$c"; then
	#					if mountit "/dev/cloop$c" "/KNOPPIX$c" "-o ro"; then
	#						echo ""
	#						echo -n "${CRE} ${GREEN}Found additional KNOPPIX compressed image at ${MAGENTA}$1/$KNOPPIX_DIR/$KNOPPIX_NAME$c${GREEN}.${NORMAL}"
	#					else
	#						"$DYNLOADER" --library-path /KNOPPIX/lib /KNOPPIX/bin/rmdir "/KNOPPIX$c" 2>/dev/null
	#					fi
	#				else
	#					"$DYNLOADER" --library-path /KNOPPIX/lib /KNOPPIX/bin/losetup -d "/dev/cloop$c" 2>/dev/null
	#				fi
	#			fi
	#		fi
	#	done
	#fi
}

remount_knoppix()
{
	if test -f $TARGET/$FLL_IMAGE; then
		umount $FLL_MOUNTPOINT
# FIXME
# as multi-image mounts are commented out of mount_knoppix
#		for c in 0 1 2 3 4 5 6 7; do
#			umount "/$KNOPPIX_NAME$c" >/dev/null 2>&1
#		done
	
		if [ "$COMP" == "cloop" ]; then
			unloadmodule cloop # release CD
		fi

		umount $SOURCE  # unmount CD
		[ -n "$SOURCE2" ] && umount $SOURCE2  # umount possible loop-device

		mount_knoppix $TARGET
	else
		echo "${CRE} ${RED}Warning: Changing to $TARGET failed.${NORMAL}"
		return 1
	fi

	return 0
}

boot_from()
{
	# preparations
	/bin/mkdir $TARGET

	SOURCE_DEV=$(echo $CMDLINE | /usr/bin/tr ' ' '\n' | /bin/sed -n '/bootfrom=/s/.*=//p' | /usr/bin/tail -1)
	LOOP_DEV=$(echo $SOURCE_DEV | /usr/bin/gawk -F/ '{ print $1 "/" $2 "/" $3 }')
	ISO_PATH=$(echo $SOURCE_DEV | /bin/sed "s|$LOOP_DEV||g" )
	case "$ISO_PATH" in
		/*.[iI][sS][oO])
			;;
		*)
			ISO_PATH=""
			;;
	esac
	LOOP_SOURCE=""
  
	# load filesystems
	/$FLL_MOUNTPOINT/sbin/modprobe reiserfs
	/$FLL_MOUNTPOINT/sbin/modprobe ntfs
 
	if [ -n "$ISO_PATH" ]; then
		LOOP_SOURCE="$TARGET.loop"
		LOOP_SOURCE2="$LOOP_SOURCE"
		TARGET_DEV="$LOOP_SOURCE$ISO_PATH"
		/bin/mkdir $LOOP_SOURCE
		/$FLL_MOUNTPOINT/sbin/modprobe loop

		/bin/mount -o ro $LOOP_DEV $LOOP_SOURCE || LOOP_SOURCE=""
		/bin/mount -n -o loop $LOOP_SOURCE2$ISO_PATH $TARGET
	else
		TARGET_DEV="$SOURCE_DEV"
		/bin/mount -n -o ro $SOURCE_DEV $TARGET
	fi

	if [ $? -ne 0 ]; then
		[ -n "$LOOP_SOURCE" ] && /bin/umount $LOOP_SOURCE
		echo -n "${CRE} ${RED}Accessing $FLL_DISTRO_NAME $FLL_MEDIUM failed. ${MAGENTA}$TARGET_DEV${RED} is not mountable.${NORMAL}"
		sleep 2
		
		return 1
	fi
  
	if [ -f $TARGET/$FLL_IMAGE ]; then
		echo -n "${CRE} ${GREEN}Accessing $FLL_DISTRO_NAME $FLL_MEDIUM at ${MAGENTA}$TARGET_DEV${GREEN}...${NORMAL}"
	else
		echo -n "${CRE} ${RED}Accessing $FLL_DISTRO_NAME $FLL_MEDIUM failed. Could not find $FLL_IMAGE on ${MAGENTA}$TARGET_DEV${RED}.${NORMAL}"
		[ -n "$LOOP_SOURCE" ] && /bin/umount $LOOP_SOURCE
		umount $TARGET
		sleep 2
	
		return 1
	fi

	# remount the CD 
	remount_knoppix
}

copy_to()
{
	# preparations
	/bin/mkdir $TARGET
	COPY="$SOURCE/$FLL_IMAGE_DIR"
	
	# look if we copy to hd or to ram
	SIZE="$(/usr/bin/du -s $COPY | /usr/bin/gawk '{print int($1*1.1)}')"
	test -n "$SIZE" || SIZE="800000"
	
	case "$1" in 
		ram)
			TARGET_DEV="/dev/shm"
			TARGET_DEV_DESC="ramdisk"
			FOUNDSPACE="$(/usr/bin/gawk '/MemTotal/{print $2}' /proc/meminfo)"
			/bin/mount -n -t tmpfs -o size=${SIZE}k $TARGET_DEV $TARGET
			;;
		hd)
			TARGET_DEV=$(echo $CMDLINE | /usr/bin/tr ' ' '\n' | /bin/sed -n '/tohd=/s/.*=//p' | /usr/bin/tail -1)
			TARGET_DEV_DESC="$TARGET_DEV"

			# load filesystems
			/$FLL_MOUNTPOINT/sbin/modprobe reiserfs
			/$FLL_MOUNTPOINT/sbin/modprobe jbd
			/$FLL_MOUNTPOINT/sbin/modprobe ext3
			#/$FLL_MOUNTPOINT/sbin/modprobe fuse	#we don't allow writing to ntfs, sorry
			FS="ext3 ext2 reiserfs vfat"
			MOUNTED=""
			
			for i in $FS; do
				if /$FLL_MOUNTPOINT/bin/mount -o rw -t "$i" "$TARGET_DEV" "$TARGET"; then
					MOUNTED="true"
					break
				fi
			done
			
			if test -z "$MOUNTED"; then
				echo -n "${CRE}${RED}Copying $FLL_DISTRO_NAME ${FLL_MEDIUM} failed. ${MAGENTA}$TARGET_DEV_DESC${RED} is not mountable.${NORMAL}"
				sleep 2

				return 1
			fi
			
			# check for enough free space
			USED_SPACE=0
			test -r $TARGET/$FLL_IMAGE && USED_SPACE=$(/usr/bin/du -s $TARGET/$FLL_IMAGE | /usr/bin/gawk '{ print $1 }')
			FOUNDSPACE="$(/bin/df -k $TARGET | /usr/bin/tail -1 | /usr/bin/gawk '{ print $4+int('$USED_SPACE') }')"
			;;
		*)
			return 1
			;;
	esac
	
	# sanity check
	if [ $FOUNDSPACE -lt $SIZE ]; then
		echo -n "${CRE} ${RED}Copying $FLL_DISTRO_NAME $FLL_MEDIUM failed. Not enough free space on ${MAGENTA}${TARGET_DEV_DESC}${RED}. Found: ${MAGENTA}${FOUNDSPACE}k${RED} Need: ${MAGENTA}${SIZE}k${RED} ${NORMAL}"
		sleep 2
		umount $TARGET

		return 1
	fi
	
	# do the real copy
	echo "${CRE} ${GREEN}Copying $FLL_DISTRO_NAME $FLL_MEDIUM to ${MAGENTA}$TARGET_DEV_DESC${GREEN}... Please be patient. ${NORMAL}"

	if [ -z "$COPY_COMMAND" ] && [ -x /usr/bin/rsync ]; then
		# first cp the small files
		/usr/bin/rsync -a --exclude="$FLL_IMAGE*" $COPY $TARGET # Copy Knoppix to $TARGET

		# then the big file with nice progress meter
		/usr/bin/rsync -a --progress --include="$FLL_IMAGE*" --include="$FLL_IMAGE_DIR/" --exclude="*" $COPY $TARGET
	else
		"$COPY_COMMAND" $COPY $TARGET
	fi

	if [ $? -ne 0 ]; then
		echo -n "${CRE} ${RED}Copying $FLL_DISTRO_NAME $FLL_MEDIUM failed. ${MAGENTA}$TARGET_DEV_DESC${RED} possibly has not enough space left.${NORMAL}"
		sleep 2

		return 1
	fi

	# remount r/o
	/bin/mount -n -o remount,ro $TARGET
	remount_knoppix
}

mount_knoppix /$FLL_MEDIUM

COPYTO=""
BOOTFROM=""
DO_REMOUNT=""
REAL_TARGET=""
UNIONFS=""

case "$CMDLINE" in
	 *toram*)
	 	DO_REMOUNT="yes"
		COPYTO="ram"
		;;
esac

case "$CMDLINE" in
	*tohd=*)
		DO_REMOUNT="yes"
		COPYTO="hd"
		;;
esac

case "$CMDLINE" in
	*bootfrom=*)
		DO_REMOUNT="yes"
		BOOTFROM="yes"
		;;
esac
 
# Remount later after copying/isoloading/driverloading?
# pre-test if everything succeeded
if  test -n "$DO_REMOUNT" -a -n "$FOUND_KNOPPIX"; then
	# copy library cache 
	cat /$FLL_MOUNTPOINT/etc/ld.so.cache > /etc/ld.so.cache 
	echo "" 
	
	SOURCE="/${FLL_MEDIUM}"
	TARGET="/${FLL_MEDIUM}2"
	
	# first test for possible hdboot/fromiso (which can be combined with toram / tohd)
	if [ -n "$BOOTFROM" ]; then
		boot_from
		if [ $? -eq 0 ]; then
			# set new source / target paths
			REAL_TARGET="$TARGET"
			SOURCE2="$LOOP_SOURCE"
			SOURCE="/${FLL_MEDIUM}2"
			TARGET="/${FLL_MEDIUM}3"
		fi
	fi

	if [ -n "$COPYTO" ]; then
		copy_to $COPYTO && REAL_TARGET="$TARGET"
	fi
fi
 
# Final test if everything succeeded.
if test -n "$FOUND_KNOPPIX"; then
	# copy library cache
	cat /$FLL_MOUNTPOINT/etc/ld.so.cache > /etc/ld.so.cache
	echo ""

	# don't use unionfs unconditionally for now
	case "$CMDLINE" in
		*unionfs*)
			loadmodule unionfs 2>/dev/null && UNIONFS="yes"
			;;
	esac
	
	# Enable kernel messages
	echo "6" > /proc/sys/kernel/printk
	
	# Set paths
	echo -n "${CRE}${BLUE}Setting paths...${NORMAL}"
	PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11"
	export PATH

	# Debian weirdness
	/$FLL_MOUNTPOINT/bin/cp -a /$FLL_MOUNTPOINT/etc/alternatives /etc/ 2>/dev/null
	
	# Replace /sbin
	/$FLL_MOUNTPOINT/bin/rm -f /sbin
	/$FLL_MOUNTPOINT/bin/ln -sf /$FLL_MOUNTPOINT/sbin /sbin
	
	# From here, we should have all essential commands available.
	hash -r
	
	# Did we remount the source media ? 
	if  test -n "$REAL_TARGET"; then
		/bin/mount -n --move $REAL_TARGET /$FLL_MEDIUM # move it back and go on to normal boot 
	fi
	
	# Clean up /
	/$FLL_MOUNTPOINT/bin/rm -rf /modules /static
	
	# New in Kernel 2.4.x: tempfs with variable ramdisk size.
	# We check for available memory anyways and limit the ramdisks
	# to a reasonable size.
	FOUNDMEM="$(awk '/MemTotal/{print $2}' /proc/meminfo)"
	TOTALMEM="$(awk 'BEGIN{m=0};/MemFree|Cached/{m+=$2};END{print m}' /proc/meminfo)"
	
	# Be verbose
	echo "${CRE}${BLUE}Total memory found: ${YELLOW}${FOUNDMEM}${BLUE} kB${NORMAL}"
	
	# Now we need to use a little intuition for finding a ramdisk size
	# that keeps us from running out of space, but still doesn't crash the
	# machine due to lack of Ram
	
	# Minimum size of additional ram partitions
	MINSIZE=20000

	# At least this much memory minus 30% should remain when home and var are full.
	MINLEFT=16000

	# Maximum ramdisk size
	MAXSIZE="$(expr $TOTALMEM - $MINLEFT)"

	# Default ramdisk size for ramdisk
	RAMSIZE="$(expr $TOTALMEM / 5)"

	# Create additional dynamic ramdisk.
	test -z "$RAMSIZE" -o "$RAMSIZE" -lt "$MINSIZE" && RAMSIZE="$MINSIZE"
	mkdir -p /ramdisk

	# tmpfs/varsize version, can use swap
	RAMSIZE=$(expr $RAMSIZE \* 4)
	echo -n "${CRE}${BLUE}Creating ${YELLOW}/ramdisk${BLUE} (dynamic size=${RAMSIZE}k) on ${MAGENTA}shared memory${BLUE}...${NORMAL}"

	# We need /bin/mount here for the -o size= option
	/bin/mount -t tmpfs -o "size=${RAMSIZE}k" /ramdisk /ramdisk || echo "creating the ramdisk failed"

	if [ "$UNIONS" = "yes" ]; then
		mkdir -p	/ramdisk/tmp \
				/ramdisk/home/${FLL_LIVE_USER}

		chmod 1777 /ramdisk/tmp
		chown $FLL_LIVE_USER:$FLL_LIVE_USER /ramdisk/home/${FLL_LIVE_USER}

		ln -snf /ramdisk/home /home
		mv /tmp /tmp.old
		ln -s /ramdisk/tmp /tmp
		rm -rf tmp.old
	else
		mkdir -p	/home/ \
				/var \
				/ramdisk/home \
				/ramdisk/var

		/bin/mount --bind /ramdisk/home /home
		/bin/mount --bind /ramdisk/var /var
	fi

	echo "${BLUE}Done.${NORMAL}"

	stage=2
	rundebugshell

        # don't use unionfs unconditionally for now
        if [ "$UNIONS" = "yes" ]; then
		#######################
		## unionfs adventure ##
		#######################

		echo -n "${CRE}${BLUE}Creating unionfs and symlinks on ramdisk...${NORMAL}"
		mkdir -p /UNIONFS
		UNION="/ramdisk=rw"
	
		# Add all KNOPPIX images to the union
#		for c in "" 1 2 3 4 5 6 7; do
#			[ -d "/KNOPPIX$c" ] && UNION="$UNION:/KNOPPIX$c=ro"
#		done
		# FIXME:Multi-Image
		# No multi-images in here
		[ -d "$FLL_MOUNTPOINT" ] && UNION="$UNION:/$FLL_MOUNTPOINT=ro"
		# Do the actual mount
		if /bin/mount -t unionfs -o "dirs=$UNION,delete=whiteout" /UNIONFS /UNIONFS; then
			# We now have unionfs, copy some data from the initial ramdisk first
			cp -a	/etc/fstab \
				/etc/filesystems \
				/etc/mtab \
					/UNIONFS/etc/
	
			# /dev is a special case, it is now normally handled via udev
			UNIONDEV=""
			case "$CMDLINE" in
				*noudev*)
					UNIONDEV="dev"
					;;
			esac
			
			for i in bin boot etc $UNIONDEV sbin var lib opt root usr; do
				# Move directories to unionfs
				if test -d /$i; then
					mv /$i /$i.old && $DYNLOADER --library-path /$FLL_MOUNTPOINT/lib /$FLL_MOUNTPOINT/bin/ln -snf /UNIONFS/$i /$i && rm -rf /$i.old
				else
					ln -snf /UNIONFS/$i /$i
				fi
			done
	
			for i in $(cd /UNIONFS; echo *); do
				# Create links for new stuff on /UNIONFS
				test "$i" = "home" -o "$i" = "tmp" && continue
				test -L "/$i" || test -d "/$i" || test -f "/$i" || ln -snf "/UNIONFS/$i" /$i
			done
		else
			echo -n "${CRE}${RED}ERROR: CANNOT UNITE READ-ONLY MEDIA AND INITIAL RAMDISK!${NORMAL}"
			/$FLL_MOUNTPOINT/sbin/halt -f -n
		fi
	
		echo ""
		echo "${GREEN}>> Read-only ${FLL_MEDIUM} system successfully merged with read-write /ramdisk.${NORMAL}"
		chown ${FLL_LIVE_USER}:${FLL_LIVE_USER} /home/${FLL_LIVE_USER}

		#######################
	else
		###############
		## link farm ##
		###############

		echo -n "${CRE}${BLUE}Creating directories and symlinks on ramdisk...${NORMAL}"
		# Create common WRITABLE (empty) dirs
		mkdir -p	/var/run \
				/var/backups \
				/var/cache/apache \
				/var/local \
				/var/lock/news \
				/var/nis \
				/var/preserve \
				/var/state/misc \
				/var/tmp \
				/var/lib \
				/var/spool/cups/tmp \
				/var/lib/samba \
				/home/${FLL_LIVE_USER} \
				/root \
				/etc/sysconfig \
				/etc/X11 \
				/etc/cups \
				/etc/dhcpc
		chown ${FLL_LIVE_USER}:${FLL_LIVE_USER} /home/${FLL_LIVE_USER}

		# All files in here should be size zero after Knoppix.clean was run
		cp -a	/$FLL_MOUNTPOINT/var/local \
			/$FLL_MOUNTPOINT/var/games \
			/$FLL_MOUNTPOINT/var/log \
			/$FLL_MOUNTPOINT/var/spool \
				/var/ 2>/dev/null
		cp -a	/$FLL_MOUNTPOINT/var/lib/games \
			/$FLL_MOUNTPOINT/var/lib/wine \
			/$FLL_MOUNTPOINT/var/lib/nfs \
			/$FLL_MOUNTPOINT/var/lib/xkb \
			/$FLL_MOUNTPOINT/var/lib/isdn \
			/$FLL_MOUNTPOINT/var/lib/kdm \
			/$FLL_MOUNTPOINT/var/lib/pcmcia \
			/$FLL_MOUNTPOINT/var/lib/dhcp* \
				/var/lib/ 2>/dev/null
	
		# Link device files (real device file copies should NOT require more space, but in fact, they do)
		cp -aus /dev/capi /dev/ 2>/dev/null
		ln -s /$FLL_MOUNTPOINT/dev/* /dev/ 2>/dev/null
	
		# Problematic directories in /var/lib (lots and lots of inodes)
		ln -s	/$FLL_MOUNTPOINT/var/lib/dpkg \
			/$FLL_MOUNTPOINT/var/lib/apt \
			/$FLL_MOUNTPOINT/var/lib/doc-base \
			/$FLL_MOUNTPOINT/var/lib/gnome \
			/$FLL_MOUNTPOINT/var/lib/kde \
			/$FLL_MOUNTPOINT/var/lib/scrollkeeper \
			/$FLL_MOUNTPOINT/var/lib/texmf \
				/var/lib/ 2>/dev/null
	
		# Debian-apt
		ln -s /$FLL_MOUNTPOINT/var/cache/apt /var/cache/ 2>/dev/null
		ln -s /$FLL_MOUNTPOINT/etc/skel /etc/ 2>/dev/null
	
		# Index files can be HUGE, so better replace cache/man tree by links later
		# cp -a /$FLL_MOUNTPOINT/var/cache/man /var/cache/ 2>/dev/null
		# Create links from CDROM for UNWRITABLE (remaining) files
		cp -aus /$FLL_MOUNTPOINT/var/* /var/ 2>/dev/null
		cp -aus /$FLL_MOUNTPOINT/etc/* /etc/ 2>/dev/null

		###############
	fi

	# CUPS wants writable files. :-/
	cp -a /$FLL_MOUNTPOINT/etc/cups/*.conf /etc/cups/ 2>/dev/null
	
	# resolv.conf must be writable as well
	rm -f /etc/resolv.conf 2>/dev/null
	touch /etc/resolv.conf

	# Make SURE that these are files, not links!
	rm -rf	/etc/ftpusers \
		/etc/passwd \
		/etc/shadow \
		/etc/gshadow \
		/etc/group \
		/etc/ppp \
		/etc/isdn \
		/etc/ssh \
		/etc/ioctl.save \
		/etc/inittab \
		/etc/network \
		/etc/sudoers \
		/etc/init \
		/etc/localtime \
		/etc/dhcpc \
		/etc/pnm2ppa.conf 2>/dev/null

	cp -a	/$FLL_MOUNTPOINT/etc/ftpusers \
		/$FLL_MOUNTPOINT/etc/passwd \
		/$FLL_MOUNTPOINT/etc/shadow \
		/$FLL_MOUNTPOINT/etc/gshadow \
		/$FLL_MOUNTPOINT/etc/group \
		/$FLL_MOUNTPOINT/etc/ppp \
		/$FLL_MOUNTPOINT/etc/isdn \
		/$FLL_MOUNTPOINT/etc/ssh \
		/$FLL_MOUNTPOINT/etc/inittab \
		/$FLL_MOUNTPOINT/etc/network \
		/$FLL_MOUNTPOINT/etc/sudoers \
		/$FLL_MOUNTPOINT/sbin/init \
		/$FLL_MOUNTPOINT/etc/dhcpc \
			/etc/ 2>/dev/null

	# Create empty utmp and wtmp
	# /etc/ioctl.save and /etc/pnm2ppa.conf are extremly important, init crashes on shutdown if this is only a link
	# get rid of broken xorg.conf
	rm -f	/var/run/utmp \
		/var/run/wtmp \
		/etc/ioctl.save \
		/etc/pnm2ppa.conf \
		/etc/X11/xorg.conf \
		/var/lib/samba/unexpected.tdb
	:>	/var/run/utmp
	:>	/var/run/wtmp
	:>	/etc/ioctl.save
	:>	/etc/pnm2ppa.conf

	# Must exist for samba to work
	[ -d /var/lib/samba ] && :> /var/lib/samba/unexpected.tdb

	# Diet libc bug workaround
	/bin/cp -f /$FLL_MOUNTPOINT/etc/localtime /etc/localtime

	# busybox/cloop workaround
	chmod 1777 /tmp /var/tmp
	
	echo "${BLUE}Done.${NORMAL}"

	# Clean up /etc/mtab (and - just in case - make a nice entry for looped ISO)
	# FIXME Multi-Image
	/bin/egrep " /$FLL_MOUNTPOINT | /$FLL_MEDIUM " /proc/mounts | sed 's|/dev/loop0 /$FLL_MEDIUM \(.*\) 0 0|'$LOOP_SOURCE$ISO_PATH' /$FLL_MEDIUM/ \1,loop=/dev/loop0 0 0|g' >> /etc/mtab

	# Now tell kernel where the real modprobe lives
	echo "/sbin/modprobe" > /proc/sys/kernel/modprobe
	
	# Change root device from /dev/fd0 to /dev/ram0
	echo "0x100" > /proc/sys/kernel/real-root-dev

	# clean up /etc/rc?.d/
	for i in 0 1 2 3 4 5 6 S; do
		rm -rf "/etc/rc${i}.d"
		mkdir -p "/etc/rc${i}.d"
		ln -fs "/$FLL_MOUNTPOINT/etc/rc${i}.d/README" "/etc/rc${i}.d/"
	done
	for i in 0 1 2 3 4 6; do
		ln -fs "/$FLL_MOUNTPOINT/etc/init.d/xsession" "/etc/rc${i}.d/K10xsession"
	done
	ln -fs "/$FLL_MOUNTPOINT/etc/init.d/live-autoconfig" "/etc/rcS.d/S00live-autoconfig"
	ln -fs "/$FLL_MOUNTPOINT/etc/init.d/live-halt" "/etc/rc0.d/S90live-halt"
	ln -fs "/$FLL_MOUNTPOINT/etc/init.d/live-reboot" "/etc/rc6.d/S90live-reboot"

	stage=3
	rundebugshell	
	# Give control to the init process.
	echo "${CRE}${BLUE}Starting init process.${NORMAL}"
	rm -f /linuxrc
	
	exit 0
else
	echo "${CRE}${RED}Can't find $FLL_DISTRO_NAME filesystem, sorry.${NORMAL}"
	echo "${RED}Dropping you to a (very limited) shell.${NORMAL}"
	echo "${RED}Press reset button to quit.${NORMAL}"
	echo ""
	
	PS1="sidux# "
	export PS1

	echo "6" > /proc/sys/kernel/printk

	# Allow signals
	trap 1 2 3 15
	exec /static/ash
fi

